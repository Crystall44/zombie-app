{"version":3,"file":"js/app.e5bbec6d.js","mappings":"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","sources":["webpack://zombie-app/./src/App.vue","webpack://zombie-app/./src/entities/Zombie.js","webpack://zombie-app/./src/entities/Human.js","webpack://zombie-app/./src/entities/Medic.js","webpack://zombie-app/./src/entities/Guardian.js","webpack://zombie-app/./src/App.vue?7ccd","webpack://zombie-app/./src/main.js","webpack://zombie-app/webpack/bootstrap","webpack://zombie-app/webpack/runtime/chunk loaded","webpack://zombie-app/webpack/runtime/compat get default export","webpack://zombie-app/webpack/runtime/define property getters","webpack://zombie-app/webpack/runtime/global","webpack://zombie-app/webpack/runtime/hasOwnProperty shorthand","webpack://zombie-app/webpack/runtime/jsonp chunk loading","webpack://zombie-app/webpack/startup"],"sourcesContent":["<script>\n// Импорт классов сущностей из соответствующих файлов\nimport {Zombie} from './entities/Zombie.js'\nimport {Human} from './entities/Human.js'\nimport {Medic} from './entities/Medic.js'\nimport {Guardian} from './entities/Guardian.js'\n  export default{\n    data() {\n      // Настройки по умолчанию для симуляции\n      const defaultSettings = {\n          population: 100,              // Общее количество людей\n          humanSpeed: 1.0,              // Скорость передвижения людей\n          zombieSpeed: 0.9,             // Скорость передвижения зомби\n          detectionRadiusHumans: 100,   // Радиус обнаружения для людей\n          infectionRadius: 25,          // Радиус заражения\n          infectionTime: 3000,          // Время заражения (мс)\n          zombiePopulation: 1,          // Начальное количество зомби\n          medicSpeed: 1.2,              // Скорость медиков\n          healingPower: 2,              // Сила лечения\n          detectionRadiusMedic: 150,    // Радиус обнаружения для медиков\n          infectionTimeMedic: 6000,     // Время заражения для медиков\n          guardianSpeed: 0.6,           // Скорость защитников\n          detectionRadiusGuardian: 100, // Радиус обнаружения для защитников\n          attackRadiusGuardian: 50,     // Радиус атаки защитников\n          medicsPopulation: 5,          // Количество медиков\n          guardiansPopulation: 5,       // Количество защитников\n          detectionRadiusZombie: 150,   // Радиус обнаружения для зомби\n          maxHealthZombie: 5,           // Максимальное здоровье зомби\n          attackPowerZombie: 1,         // Сила атаки зомби\n          attackRateZombie: 60,         // Частота атак зомби\n          attackPowerGuardian: 1,       // Сила атаки защитников\n          attackRateGuardian: 60,       // Частота атак защитников\n          maxHealthGuardian: 3          // Максимальное здоровье защитников\n        };\n      return {\n        humans: [],     // Массив для хранения людей\n        zombies: [],    // Массив для хранения зомби\n        medics: [],     // Массив для хранения медиков\n        guardians: [],  // Массив для хранения защитников\n        ctx: null,      // Контекст canvas для отрисовки\n        animationId: null,          // ID анимации\n        showHumanSettings: false,   // Флаг показа настроек людей\n        showZombieSettings: false,  // Флаг показа настроек зомби\n        showMedicSettings: false,   // Флаг показа настроек медиков\n        showGuardianSettings: false,// Флаг показа настроек защитников\n        startTime: 0,       // Время начала симуляции\n        elapsedTime: 0,     // Прошедшее время симуляции\n        pauseTime: 0,       // Время паузы\n        lastPauseTime: 0,   // Время последней паузы\n        lastTime: 0,        // Последнее зафиксированное время\n        stats: {            // Статистика симуляции\n          healthy: 0,       // Количество здоровых\n          infected: 0,      // Количество зараженных\n          zombies: 0,       // Количество зомби\n          medics: 0,        // Количество медиков\n          guardians: 0,     // Количество защитников\n          time: '00:00'     // Время симуляции\n        },\n        simulationEnd: false,   // Флаг окончания симуляции\n        minDist: 100,           // Минимальное расстояние\n        isRunning: false,       // Флаг работы симуляции\n        isPaused:false,         // Флаг паузы\n        simulationStarted: false, // Флаг начала симуляции\n        showSettings:true,      // Флаг показа настроек\n        tempSettings: null,     // Временные настройки\n        settings: JSON.parse(JSON.stringify(defaultSettings)),  // Текущие настройки\n        defaultSettings         // Настройки по умолчанию\n      }\n    },\n    \n    // Хук, вызываемый после монтирования компонента\n    mounted() {\n      this.initWorld(); // Инициализация мира\n    },\n\n    // Вычисляемые свойства\n    computed: {\n      // Текст для главной кнопки управления\n      mainButtonText() {\n        if(this.simulationEnd) return 'Начать заново';\n        if(this.isPaused) return 'Продолжить';\n        return this.isRunning ? 'Остановить' : 'Начать симуляцию';\n      }\n    },\n\n    methods: {\n          // Обработчик клика по кнопке управления\n          handleControlClick() {\n            if(this.isRunning) {\n              this.stopSim();     // Остановить симуляцию\n              this.isRunning = false;\n              this.isPaused = true;\n            } else {\n              this.startSim();    // Запустить симуляцию\n              this.isRunning = true;\n              this.isPaused = false;\n            }\n          },\n\n          // Инициализация игрового мира\n          initWorld() {\n            // Получаем контекст canvas для рисования\n            this.ctx = this.$refs.canvas.getContext('2d');\n\n            // Очищаем массивы сущностей\n            this.humans = [];\n            this.zombies = [];\n            this.medics = [];\n            this.guardians = [];\n\n            // Создание людей с случайными позициями\n            for(let i = 0; i < this.settings.population; i++) {\n              const human = new Human(Math.random() * 700 + 50, Math.random() * 500 + 50,this.settings.humanSpeed, this.settings.infectionTime, this.settings.detectionRadiusHumans);\n              this.humans.push(human);\n            }\n\n            // Создание медиков\n            for(let i = 0; i < this.settings.medicsPopulation; i++) {\n              const medic = new Medic(Math.random() * 700 + 50, Math.random() * 500 + 50, this.settings.medicSpeed, this.settings.healingPower, this.settings.detectionRadiusMedic, this.settings.infectionTimeMedic);\n              this.medics.push(medic);\n            }\n\n            // Создание защитников\n            for(let i = 0; i < this.settings.guardiansPopulation; i++) {\n              const guardian = new Guardian(Math.random() * 700 + 50, Math.random() * 500 + 50, this.settings.guardianSpeed, this.settings.detectionRadiusGuardian, this.settings.attackRadiusGuardian, this.settings.attackPowerGuardian, this.settings.attackRateGuardian, this.settings.maxHealthGuardian);\n              this.guardians.push(guardian);\n            }\n\n            // Создание зомби с учетом минимального расстояния от людей\n            for(let i = 0; i < this.settings.zombiePopulation; i++) {\n              this.spawnZombie(50);\n            }\n\n            // Запоминаем текущее время и рисуем мир\n            this.lastTime = performance.now();\n            this.drawWorld();\n          },\n\n          // Метод создания нового зомби с проверкой минимального расстояния от людей\n          spawnZombie(minDist) {\n            let attempts = 0;\n            const maxAttempts = 50; // Максимальное количество попыток\n\n            // Пытаемся найти позицию, не слишком близкую к людям\n            while (attempts < maxAttempts) {\n              const x = Math.random() * 700 + 50;\n              const y = Math.random() * 500 + 50;\n\n              // Проверяем, не слишком ли близко к людям\n              const tooClose = this.humans.some(human => human.isTooClose(x, y, minDist));\n              if(!tooClose) {\n                // Создаем зомби, если нашли подходящую позицию\n                const zombie = new Zombie(Math.random() * 700 + 50, Math.random() * 500 + 50, this.settings.zombieSpeed, this.settings.infectionRadius, this.settings.detectionRadiusZombie, this.settings.maxHealthZombie, this.settings.attackPowerZombie, this.settings.attackRateZombie);\n                this.zombies.push(zombie);\n                return;\n              }\n\n              attempts++;\n            }\n\n            // Если не нашли подходящую позицию, создаем зомби в случайном месте\n            const zombie = new Zombie(Math.random() * 700 + 50, Math.random() * 500 + 50, this.settings.zombieSpeed, this.settings.infectionRadius, this.settings.detectionRadiusZombie, this.settings.maxHealthZombie, this.settings.attackPowerZombie, this.settings.attackRateZombie);\n            this.zombies.push(zombie);\n            return;\n          },\n\n          // Отрисовка игрового мира\n          drawWorld() {\n            // Очищаем canvas\n            this.ctx.clearRect(0,0,800,600);\n\n            //Рисование людей\n            this.humans.forEach(human => {\n              // Основной круг человека\n              this.ctx.fillStyle = human.color;\n              this.ctx.beginPath();\n              this.ctx.arc(human.x, human.y, human.radius, 0, Math.PI * 2);\n              this.ctx.fill();\n\n              // Индикатор заражения (если человек заражен)\n              if(human.infectionProgress > 0) {\n                this.ctx.strokeStyle = 'rgba(200, 0, 0, 0.7)';\n                this.ctx.lineWidth = 2;\n                this.ctx.beginPath();\n                this.ctx.arc(human.x, human.y, human.radius + 3, -Math.PI/2, -Math.PI/2 + 2 * Math.PI * human.infectionProgress/100);\n                this.ctx.stroke();\n              }\n            })\n\n            // Рисуем медиков\n             this.medics.forEach(medic => {\n              // Основной круг медика\n              this.ctx.fillStyle = medic.color;\n              this.ctx.beginPath();\n              this.ctx.arc(medic.x, medic.y, medic.radius, 0, Math.PI*2);\n              this.ctx.fill();\n\n              // Индикатор заражения (если медик заражен)\n              if(medic.infectionProgress > 0) {\n                  this.ctx.strokeStyle = 'rgba(200, 0, 0, 0.7)';\n                  this.ctx.lineWidth = 2;\n                  this.ctx.beginPath();\n                  this.ctx.arc(\n                      medic.x, medic.y, \n                      medic.radius + 3, \n                      -Math.PI/2, \n                      -Math.PI/2 + 2 * Math.PI * medic.infectionProgress/100\n                  );\n                  this.ctx.stroke();\n              }\n\n              // Анимация лечения (пульсирующий круг)\n              if (medic.isHealing) {\n                  // Пульсирующий зеленый круг\n                  const pulse = Math.sin(Date.now() / 300) * 2; // Простая пульсация\n                  this.ctx.strokeStyle = 'rgba(100, 255, 180, 0.8)';\n                  this.ctx.lineWidth = 2;\n                  this.ctx.beginPath();\n                  this.ctx.arc(medic.x, medic.y, medic.radius + 3 + pulse, 0, Math.PI*2);\n                  this.ctx.stroke();\n              }\n              })\n\n              // Рисуем защитников\n              this.guardians.forEach(guardian => {\n                // Основной круг защитника\n                this.ctx.save();\n                this.ctx.fillStyle = guardian.color;\n                this.ctx.beginPath();\n                this.ctx.arc(guardian.x, guardian.y, guardian.radius, 0, Math.PI*2);\n                this.ctx.fill();\n\n                // Металлический ободок (визуальный эффект брони)\n                this.ctx.strokeStyle = 'hsla(200, 30%, 80%, 0.8)';\n                this.ctx.lineWidth = 2;\n                this.ctx.beginPath();\n                this.ctx.arc(guardian.x, guardian.y, guardian.radius + 1, 0, Math.PI*2);\n                this.ctx.stroke();\n\n                // Область атаки (полупрозрачный круг)\n                this.ctx.fillStyle = 'rgba(80, 60, 160, 0.08)';\n                this.ctx.beginPath();\n                this.ctx.arc(guardian.x, guardian.y, guardian.attackRadius, 0, Math.PI * 2);\n                this.ctx.fill();\n\n                // Отображение здоровья, если оно не полное\n                if(guardian.health < guardian.maxHealth) {\n                const healthWidth = 20;\n                const healthHeight = 3;\n                const healthX = guardian.x - healthWidth/2;\n                const healthY = guardian.y - guardian.radius - 5;\n\n                // Фон полоски здоровья\n                this.ctx.fillStyle = \"rgba(0,0,0,0.5)\";\n                this.ctx.fillRect(healthX, healthY, healthWidth, healthHeight);\n\n                // Сама полоска здоровья (меняет цвет в зависимости от уровня)\n                const hpPercent = guardian.health / guardian.maxHealth;\n                this.ctx.fillStyle = hpPercent > 0.6 ? '#2ecc71' : hpPercent > 0.3 ? '#f39c12' : '#e74c3c';\n                this.ctx.fillRect(healthX, healthY, healthWidth * hpPercent, healthHeight);\n                this.ctx.restore();\n              }\n              })\n\n            //Рисование Зомби\n            this.zombies.forEach(zombie => {\n              this.ctx.save(); // Сохраняем текущее состояние контекста\n\n              // Основной круг зомби\n              this.ctx.fillStyle = zombie.color\n              this.ctx.beginPath()\n              this.ctx.arc(zombie.x, zombie.y, zombie.radius, 0, Math.PI * 2)\n              this.ctx.fill()\n\n              // Отображение здоровья, если оно не полное\n              if(zombie.health < zombie.maxHealth) {\n                const healthWidth = 20;\n                const healthHeight = 3;\n                const healthX = zombie.x - healthWidth/2;\n                const healthY = zombie.y - zombie.radius - 5;\n\n                // Фон полоски здоровья\n                this.ctx.fillStyle = \"rgba(0,0,0,0.5)\";\n                this.ctx.fillRect(healthX, healthY, healthWidth, healthHeight);\n\n                // Сама полоска здоровья (меняет цвет в зависимости от уровня)\n                const hpPercent = zombie.health / zombie.maxHealth;\n                this.ctx.fillStyle = hpPercent > 0.6 ? '#2ecc71' : hpPercent > 0.3 ? '#f39c12' : '#e74c3c';\n                this.ctx.fillRect(healthX, healthY, healthWidth * hpPercent, healthHeight);\n              }\n\n              // Отображение зоны заражения (полупрозрачный красный круг)\n              this.ctx.fillStyle = 'rgba(139, 0, 0, 0.1)';\n              this.ctx.beginPath();\n              this.ctx.arc(zombie.x, zombie.y, zombie.infectionRadius, 0, Math.PI * 2);\n              this.ctx.fill();\n\n              // Восстанавливаем состояние контекста\n              this.ctx.restore();\n            })\n\n            // Обновление статистики\n            this.updateStats();\n          },\n\n          // Сохранение настроек\n          saveSettings() {\n            this.tempSettings = JSON.parse(JSON.stringify(this.settings));  // Сохраняем текущие настройки\n            this.showSettings = false;  // Скрываем панель настроек\n            this.initWorld(); // Перезапускаем мир с новыми настройками\n          },\n\n          // Отмена изменений настроек\n          cancelSettings() {\n            // Восстанавливаем предыдущие настройки\n            if (this.tempSettings) {\n              this.settings = JSON.parse(JSON.stringify(this.tempSettings));\n              this.$nextTick(() => {\n              this.$forceUpdate(); // Принудительное обновление компонента\n            })\n            }\n\n            this.showSettings = true; // Показываем панель настроек\n          },\n\n          // Сброс настроек к значениям по умолчанию\n          resetSettings() {\n            this.settings = JSON.parse(JSON.stringify(this.defaultSettings));\n\n            this.$nextTick(() =>{\n              this.$forceUpdate();  // Принудительное обновление компонента\n              this.initWorld();     // Перезапускаем мир\n            })\n          },\n\n          // Запуск симуляции\n          startSim() {\n            if(!this.simulationStarted) {\n              // Первый запуск - инициализация времени\n              this.startTime = performance.now();\n              this.pauseTime = 0;\n              this.elapsedTime = 0;\n              this.simulationEnd = false;\n              this.simulationStarted = true;\n            } else {\n              if(this.isPaused) {\n                // Продолжение после паузы - корректировка времени\n                this.pauseTime += performance.now() - this.lastPauseTime;\n                this.isPaused = false;\n              }\n            }\n            this.lastTime = performance.now();\n            this.animationId = requestAnimationFrame(this.update); // Запуск игрового цикла\n          },\n\n          // Остановка симуляции\n          stopSim() {\n            cancelAnimationFrame(this.animationId); // Остановка анимации\n            this.lastPauseTime = performance.now(); // Запоминаем время паузы\n          },\n\n          // Полный сброс симуляции\n          resetSim() {\n            this.stopSim(); // Останавливаем симуляцию\n\n            // Сбрасываем все данные\n            this.humans = [];\n            this.zombies = [];\n            this.medics = [];\n            this.guardians = [];\n            this.startTime = 0;\n            this.pauseTime = 0;\n            this.lastPauseTime = 0;\n            this.elapsedTime = 0;\n            this.simulationEnd = false;\n            this.simulationStarted = false;\n            this.isPaused = false;\n            this.isRunning = false;\n\n            // Сбрасываем статистику\n            this.stats = { healthy: 0, infected: 0, zombies: 0, medics: 0, guardians: 0, time: '00:00'};\n\n            this.showSettings = true; // Показываем настройки\n            this.initWorld();         // Инициализируем мир заново\n          },\n\n          // Основной игровой цикл обновления\n          update(currentTime) {\n            if(!this.isRunning) return;   // Если симуляция не запущена - выходим\n\n            // Вычисляем время, прошедшее с предыдущего кадра\n            const deltaTime = currentTime - this.lastTime\n            this.lastTime = currentTime\n\n            // Движение всех сущностей\n            // Люди убегают от зомби\n            this.humans.forEach(h => h.move(this.zombies, this.medics))\n            // Зомби преследуют людей\n            this.zombies.forEach(z => z.move(this.humans, this.medics, this.guardians))\n            // Медики лечат людей\n            this.medics.forEach(m => m.move(this.humans, this.zombies, this.medics))\n            // Защитники атакуют зомби\n            this.guardians.forEach(g => g.move(this.zombies))\n\n            // Проверка заражения людей\n            this.humans.forEach(human => {\n              this.zombies.forEach(zombie =>{\n                // Проверяем расстояние до зомби\n                const dist = Math.hypot(zombie.x - human.x, zombie.y - human.y);\n                if (dist < zombie.infectionRadius && human.infectionProgress === 0) {\n                  human.infectionProgress = 0.1; // Начинаем заражение\n                }\n              })\n\n              //Обновление прогресса заражения\n              if(human.infectionProgress > 0){\n                human.updateInfection(deltaTime)\n              }\n            })\n\n            // Проверка заражения медиков (аналогично людям)\n            this.medics.forEach(medic => {\n              this.zombies.forEach(zombie =>{\n                const dist = Math.hypot(zombie.x - medic.x, zombie.y - medic.y)\n                if (dist < zombie.infectionRadius && medic.infectionProgress === 0) {\n                  medic.infectionProgress = 0.1\n                }\n              })\n\n              //Обновление прогресса заражения\n              if(medic.infectionProgress > 0){\n                medic.updateInfection(deltaTime)\n              }\n            })\n\n            // Превращение заражённых медиков в зомби\n            this.medics = this.medics.filter(medic => {\n              if (medic.infectionProgress >= 100) {\n                // Создаем нового зомби на месте медика\n                const zombie = new Zombie(medic.x, medic.y, this.settings.zombieSpeed, this.settings.infectionRadius);\n                this.zombies.push(zombie);\n                return false;      // Удаляем медика из массива\n              }\n              return true;\n            })\n\n            // Превращение заражённых людей в зомби\n            this.humans = this.humans.filter(human => {\n              if (human.infectionProgress >= 100) {\n                const zombie = new Zombie(human.x, human.y, this.settings.zombieSpeed, this.settings.infectionRadius);\n                this.zombies.push(zombie);\n                return false;\n              }\n              return true;\n            })\n\n            // Удаление мертвых зомби\n            this.zombies = this.zombies.filter(z => {\n              if(z.health <= 0) {\n                return false;\n              }\n              return true;\n            })\n\n            // Удаление мертвых защитников\n            this.guardians = this.guardians.filter(g => {\n              if(g.health <= 0) {\n                return false;\n              }\n              return true;\n            })\n\n            // Обновление статистики\n            this.updateStats()\n\n            // Перерисовка мира\n            this.drawWorld()\n\n            // Проверка условий окончания игры\n            if((this.humans.length > 0 || this.medics.length > 0) && (this.zombies.length > 0)) {\n              // Продолжаем симуляцию, если есть и люди/медики, и зомби\n              this.animationId = requestAnimationFrame(this.update)\n            } else {\n              // Завершаем симуляцию\n              this.simulationEnd = true;\n              this.isRunning = false;\n              return;\n            }\n          },\n\n          // Обновление статистики\n          updateStats() {\n            // Расчет прошедшего времени с учетом пауз\n            if(this.simulationStarted && !this.isPaused){\n              this.elapsedTime = performance.now() - this.startTime - this.pauseTime;\n            }\n\n            // Формирование объекта статистики\n            this.stats = {\n              healthy: this.humans.filter(h => h.infectionProgress === 0).length, // Здоровые люди\n              infected: (this.humans.filter(h => h.infectionProgress > 0).length + this.medics.filter(m => m.infectionProgress > 0).length),  // Зараженные\n              zombies: this.zombies.length, // Количество зомби\n              medics: this.medics.filter(m => m.infectionProgress === 0).length,  // Здоровые медики\n              guardians: this.guardians.filter(g => g.health > 0).length, // Живые защитники\n              // Форматирование времени в MM:SS\n              time: `${Math.floor((Math.floor(this.elapsedTime/1000))/60).toString().padStart(2, '0')}:${(Math.floor(this.elapsedTime/1000) % 60).toString().padStart(2, '0')}` \n            }\n          },\n\n          // Показать сообщение об окончании игры\n          showEndMessage(message) {\n            alert(message);\n          },\n\n          // Хук, вызываемый перед уничтожением компонента\n          beforeDestroy() {\n            cancelAnimationFrame(this.animationId)\n          }\n        }\n      }\n</script>\n\n<template>\n  <div class=\"simulation-container\">\n    <!-- Основной canvas для отрисовки симуляции -->\n    <canvas ref=\"canvas\" width=\"800\" height=\"600\" class=\"simulation-canvas\"></canvas>\n    <div class=\"controls-panel\">\n      <!-- Панель управления -->\n      <div class=\"buttons-container\">\n      <!-- Главная кнопка управления (старт/пауза/стоп) -->\n      <button v-if=\"!simulationEnd\" @click=\"handleControlClick\" :class=\"['control-button', {\n        'stop-button': isRunning,\n        'continue-button': isPaused && !simulationEnd,\n        'start-button': !isRunning && !isPaused\n        }]\">{{ mainButtonText }}</button>\n\n      <!-- Кнопка сброса симуляции -->\n      <button \n        v-if=\"isPaused || simulationEnd\"\n        @click=\"resetSim\"\n        class=\"reset-button\"\n      >Начать заново</button>\n      </div>\n\n      <!-- Блок окончания симуляции -->\n      <div v-if=\"simulationEnd\" class=\"simulation-end\">\n        <!-- Иконка результата (победа/поражение) -->\n        <div class=\"end-card\" :class=\"{ 'win': zombies.length === 0, 'loss': zombies.length > 0 }\">\n          <div class=\"end-icon\">\n            <span v-if=\"zombies.length === 0\">🎉</span>\n            <span v-else>☠️</span>\n          </div>\n          <div class=\"end-content\">\n            <h3>{{ zombies.length === 0 ? 'Победа!' : 'Симуляция завершена'}}</h3>\n\n            <!-- Различные сообщения в зависимости от исхода -->\n            <p v-if=\"zombies.length === 0\" class=\"outcome-message\">\n              Все зомби уничтожены!<br>\n              <small>Выжившие: {{ stats.healthy }} человек, {{ stats.medics }} медиков, {{ stats.guardians }} защитников.</small>\n            </p>\n\n            <p v-else-if=\"humans.length === 0 && medics.length === 0 && guardians.length === 0\" class=\"outcome-message\">\n              Зомби апокалипсис наступил!<br>\n              <small>Все люди превратились в {{ stats.zombies }} зомби.</small>\n            </p>\n\n            <p v-else-if=\"humans.length === 0 && medics.length === 0 && guardians.length > 0\" class=\"outcome-message\">\n              Защитники устояли<br>\n              <small>Но все мирные жители погибли (осталось {{ stats.guardians }} защитников).</small>\n            </p>\n\n            <!-- Блок с временем симуляции -->\n            <div class=\"time-stats\">\n              <span class=\"time-icon\">⏱️</span>\n              Время симуляции: {{ stats.time }}\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Панель настроек (отображается перед началом симуляции) -->\n      <div v-if=\"!simulationStarted\" class=\"settings-panel\">\n        <div class=\"setting-item\">\n          <!-- Настройки людей -->\n          <div class=\"setting-label-with-icon\">\n            <label>Количество людей: {{  settings.population  }}</label>\n            <button @click=\"showHumanSettings = !showHumanSettings\" class=\"settings-icon-button\" title=\"Настройки\">⚙️</button>\n          </div>\n          <input type=\"range\" v-model.number=\"settings.population\" min = \"1\" max = \"300\" step=\"1\" class=\"slider\">\n\n          <!-- Дополнительные настройки людей -->\n          <div v-if=\"showHumanSettings\" class=\"mini-settings-panel\">\n            <div class=\"mini-setting-item\">\n              <label>Скорость людей: {{  settings.humanSpeed.toFixed(1)  }}</label>\n              <input type=\"range\" v-model.number=\"settings.humanSpeed\" min = \"0.1\" max = \"5\" step=\"0.1\" class=\"slider\">\n            </div>\n            <div class=\"mini-setting-item\">\n              <label>Время превращения (сек): {{  (settings.infectionTime/1000).toFixed(1)  }}</label>\n              <input type=\"range\" v-model.number=\"settings.infectionTime\" min = \"100\" max = \"10000\" step=\"100\" class=\"slider\">\n            </div>\n            <div class=\"mini-setting-item\">\n              <label>Дальность видимости: {{  settings.detectionRadiusHumans  }}</label>\n              <input type=\"range\" v-model.number=\"settings.detectionRadiusHumans\" min = \"25\" max = \"300\" step=\"5\" class=\"slider\">\n            </div>\n          </div>\n        </div>\n\n        <!-- Настройки зомби -->\n        <div class=\"setting-item\">\n          <div class=\"setting-label-with-icon\">\n            <label>Количество зомби: {{  settings.zombiePopulation  }}</label>\n            <button @click=\"showZombieSettings = !showZombieSettings\" class=\"settings-icon-button\" title=\"Настройки\">⚙️</button>\n          </div>\n          <input type=\"range\" v-model.number=\"settings.zombiePopulation\" min = \"1\" max = \"50\" step=\"1\" class=\"slider\">\n\n          <!-- Дополнительные настройки зомби -->\n          <div v-if=\"showZombieSettings\" class=\"mini-settings-panel\">\n            <div class=\"mini-setting-item\">\n              <label>Скорость зомби: {{  settings.zombieSpeed  }}</label>\n              <input type=\"range\" v-model.number=\"settings.zombieSpeed\" min = \"0.1\" max = \"5\" step=\"0.1\" class=\"slider\">\n            </div>\n            <div class=\"mini-setting-item\">\n              <label>Радиус заражения: {{  settings.infectionRadius  }}</label>\n              <input type=\"range\" v-model.number=\"settings.infectionRadius\" min = \"5\" max = \"100\" step=\"5\" class=\"slider\">\n            </div>\n            <div class=\"mini-setting-item\">\n              <label>Дальность видимости: {{  settings.detectionRadiusZombie  }}</label>\n              <input type=\"range\" v-model.number=\"settings.detectionRadiusZombie\" min = \"25\" max = \"300\" step=\"5\" class=\"slider\">\n            </div>\n            <div class=\"mini-setting-item\">\n              <label>Здоровье зомби: {{  settings.maxHealthZombie  }}</label>\n              <input type=\"range\" v-model.number=\"settings.maxHealthZombie\" min = \"1\" max = \"25\" step=\"1\" class=\"slider\">\n            </div>\n            <div class=\"mini-setting-item\">\n              <label>Сила аттаки: {{  settings.attackPowerZombie  }}</label>\n              <input type=\"range\" v-model.number=\"settings.attackPowerZombie\" min = \"1\" max = \"25\" step=\"1\" class=\"slider\">\n            </div>\n            <div class=\"mini-setting-item\">\n              <label>Задержка между аттаками: {{  (settings.attackRateZombie/60).toFixed(1)  }}</label>\n              <input type=\"range\" v-model.number=\"settings.attackRateZombie\" min = \"30\" max = \"600\" step=\"30\" class=\"slider\">\n            </div>\n          </div>\n        </div>\n\n        <!-- Блок настроек медиков -->\n        <div class=\"setting-item\">\n          <div class=\"setting-label-with-icon\">\n            <label>Количество медиков: {{  settings.medicsPopulation  }}</label>\n            <button @click=\"showMedicSettings = !showMedicSettings\" class=\"settings-icon-button\" title=\"Настройки\">⚙️</button>\n          </div>\n          <input type=\"range\" v-model.number=\"settings.medicsPopulation\" min = \"0\" max = \"25\" step = \"1\" class = \"slider\">\n\n          <!-- Дополнительные настройки медиков -->\n          <div v-if=\"showMedicSettings\" class=\"mini-settings-panel\">\n            <div class=\"mini-setting-item\">\n              <label>Скорость медиков: {{  settings.medicSpeed  }}</label>\n              <input type=\"range\" v-model.number=\"settings.medicSpeed\" min = \"0.1\" max = \"5\" step = \"0.1\" class = \"slider\">\n            </div>\n            <div class=\"mini-setting-item\">\n              <label>Скорость лечения: {{  settings.healingPower  }}</label>\n              <input type=\"range\" v-model.number=\"settings.healingPower\" min = \"0.5\" max = \"20\" step = \"0.5\" class = \"slider\">\n            </div>\n            <div class=\"mini-setting-item\">\n              <label>Дальность видимости: {{  settings.detectionRadiusMedic  }}</label>\n              <input type=\"range\" v-model.number=\"settings.detectionRadiusMedic\" min = \"25\" max = \"300\" step = \"5\" class = \"slider\">\n            </div>\n            <div class=\"mini-setting-item\">\n              <label>Время превращения в зомби(сек): {{  (settings.infectionTimeMedic/1000).toFixed(1)  }}</label>\n              <input type=\"range\" v-model.number=\"settings.infectionTimeMedic\" min = \"100\" max = \"10000\" step = \"100\" class = \"slider\">\n            </div>\n          </div>\n        </div>\n        \n        <!-- Блок настроек защитников -->\n        <div class=\"setting-item\">\n        <div class=\"setting-label-with-icon\">\n          <label>Количество защитников: {{ settings.guardiansPopulation }}</label>\n          <button @click=\"showGuardianSettings = !showGuardianSettings\" class=\"settings-icon-button\" title=\"Настройки\">⚙️</button>\n        </div>\n          <input type=\"range\" v-model.number=\"settings.guardiansPopulation\" min = \"0\" max = \"25\" step = \"1\" class = \"slider\">\n\n          <!-- Дополнительные настройки защитников -->\n          <div v-if=\"showGuardianSettings\" class=\"mini-settings-panel\">\n            <div class=\"mini-settings-item\">\n              <label>Скорость защитников: {{  settings.guardianSpeed  }}</label>\n              <input type=\"range\" v-model.number=\"settings.guardianSpeed\" min = \"0.1\" max = \"5\" step = \"0.1\" class = \"slider\">\n            </div>\n            <div class=\"mini-settings-item\">\n              <label>Дальность видимости: {{  settings.detectionRadiusGuardian  }}</label>\n              <input type=\"range\" v-model.number=\"settings.detectionRadiusGuardian\" min = \"25\" max = \"300\" step = \"5\" class = \"slider\">\n            </div>\n            <div class=\"mini-settings-item\">\n              <label>Дальность аттаки: {{  settings.attackRadiusGuardian  }}</label>\n              <input type=\"range\" v-model.number=\"settings.attackRadiusGuardian\" min = \"5\" max = \"100\" step = \"5\" class = \"slider\">\n            </div>\n            <div class=\"mini-settings-item\">\n              <label>Сила аттаки: {{  settings.attackPowerGuardian  }}</label>\n              <input type=\"range\" v-model.number=\"settings.attackPowerGuardian\" min = \"1\" max = \"25\" step = \"1\" class = \"slider\">\n            </div>\n            <div class=\"mini-settings-item\">\n              <label>Задержка между аттаками: {{  (settings.attackRateGuardian/60).toFixed(1)  }}</label>\n              <input type=\"range\" v-model.number=\"settings.attackRateGuardian\" min = \"30\" max = \"600\" step = \"30\" class = \"slider\">\n            </div>\n            <div class=\"mini-settings-item\">\n              <label>Здоровье защитника: {{  settings.maxHealthGuardian  }}</label>\n              <input type=\"range\" v-model.number=\"settings.maxHealthGuardian\" min = \"1\" max = \"25\" step = \"1\" class = \"slider\">\n            </div>\n          </div>\n        </div>\n\n        <!-- Кнопки управления настройками -->\n        <div class=\"settings-button\">\n          <button @click=\"saveSettings\" class=\"settings-control-button\">Сохранить</button>\n          <button @click=\"cancelSettings\" class=\"settings-cancel-button\">Отменить</button>\n          <button @click=\"resetSettings\" class=\"settings-reset-button\">Сбросить</button>\n        </div>\n      </div>\n\n      <!-- Блок статистики (отображается во время симуляции) -->\n      <div v-if=\"simulationStarted || isRunning\" class=\"stats\">\n        <div class=\"stat-item\">\n          <span class=\"stat-label\">Здоровые:</span>\n          <span class=\"stat-value\">{{ stats.healthy }}</span>\n        </div>\n        <div class=\"stat-item\">\n          <span class=\"stat-label\">Зараженные:</span>\n          <span class=\"stat-value\">{{ stats.infected }}</span>\n        </div>\n        <div class=\"stat-item\">\n          <span class=\"stat-label\">Зомби:</span>\n          <span class=\"stat-value\">{{ stats.zombies }}</span>\n        </div>\n        <div class=\"stat-item\">\n          <span class=\"stat-label\">Медики:</span>\n          <span class=\"stat-value\">{{ stats.medics }}</span>\n        </div>\n        <div class=\"stat-item\">\n          <span class=\"stat-label\">Защитники:</span>\n          <span class=\"stat-value\">{{ stats.guardians }}</span>\n        </div>\n        <div class=\"stat-item\">\n          <span class=\"stat-label\">Время:</span>\n          <span class=\"stat-value\">{{ stats.time }}</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n","//Класс Зомби\r\nexport class Zombie {\r\n    // Конструктор класса с параметрами по умолчанию\r\n    constructor(x, y, speed = 0.9, infectionRadius = 20, detectionRadius = 150, maxHealth = 5, attackPower = 1, attackRate = 60){\r\n        // Позиция зомби\r\n        this.x = x || Math.random() * 700 + 50;\r\n        this.y = y || Math.random() * 500 + 50;\r\n        this.radius = 7;// Радиус зомби для отрисовки\r\n        this.direction = Math.random() * Math.PI * 2;// Направление движения (случайное)\r\n        this.speed = speed;// Скорость передвижения\r\n        this.detectionRadius = detectionRadius;// Радиус обнаружения людей\r\n        this.infectionRadius = infectionRadius;// Радиус атаки/заражения\r\n        this.color = 'hsl(0, 100%, 30%)';// Цвет зомби (темно-красный)\r\n\r\n        // Система целей и таргетинга\r\n        this.currentTarget = null;// Текущая цель (человек, медик или стражник)\r\n        this.targetLockTimer = 0;// Таймер удержания цели\r\n\r\n        // Параметры для случайного блуждания\r\n        this.walkCucle = 0;// Цикл ходьбы\r\n        this.walkangle = 0;// Угол для случайного блуждания\r\n\r\n        // Параметры здоровья и атаки\r\n        this.maxHealth = maxHealth;// Максимальное здоровье\r\n        this.health = maxHealth;// Текущее здоровье\r\n        this.attackPower = attackPower;// Сила атаки\r\n        this.attackCooldown = 0;// Время перезарядки атаки\r\n        this.attackRate = attackRate;// Частота атак (в кадрах)\r\n    }\r\n\r\n    // Основной метод движения зомби\r\n    move(humans, medics, guardians) {\r\n        // Если есть текущая цель и таймер удержания цели активен, и цель не заражена\r\n        if(this.currentTarget && this.targetLockTimer > 0 && this.currentTarget.infectionProgress === 0) {\r\n            this.targetLockTimer--; // Уменьшаем таймер удержания\r\n\r\n            // Рассчитываем расстояние до цели\r\n            const dist = this.distanceTo(this.currentTarget); \r\n            \r\n            // Проверяем валидность цели (не заражена или жива) и что цель в радиусе обнаружения\r\n            const isTargetValid = (this.currentTarget.infectionProgress === 0 || this.currentTarget.health > 0) && dist < this.detectionRadius;\r\n\r\n            if(isTargetValid) {\r\n                // Если у цели есть здоровье и мы в радиусе атаки - атакуем\r\n                if(this.currentTarget.health !== undefined && dist < this.infectionRadius) {\r\n                    this.attack(this.currentTarget);\r\n                }\r\n                // Иначе если цель может быть заражена - преследуем\r\n                else if (this.currentTarget.infectionProgress !== undefined) {\r\n                    this.chase(this.currentTarget);\r\n                }\r\n                return; // Выходим из метода\r\n            }\r\n        }\r\n        // Собираем всех доступных для атаки людей (незараженные люди, медики и живые стражи)\r\n        const allHumans = [...humans.filter(h => h.infectionProgress === 0), ...medics.filter(m => m.infectionProgress === 0), ...guardians.filter(g => g.health > 0)];\r\n        // Находим ближайшего человека\r\n        const closestHuman = this.findClosestHuman(allHumans);\r\n\r\n        // Если нашли ближайшего человека и он рядом\r\n        if (closestHuman && this.isHumanNear(closestHuman)) {\r\n            // Устанавливаем его как цель\r\n            this.currentTarget = closestHuman;\r\n            this.targetLockTimer = 100; // Устанавливаем таймер удержания цели\r\n\r\n            // Если у цели есть здоровье и мы в радиусе атаки - атакуем\r\n            if(closestHuman.health !== undefined && this.distanceTo(closestHuman) < this.infectionRadius) {\r\n                this.attack(closestHuman);\r\n            } else {\r\n                // Иначе преследуем цель\r\n                this.chase(closestHuman); \r\n            }\r\n        } else {\r\n            // Если нет целей поблизости - случайное блуждание\r\n            this.randomWalk()\r\n            this.currentTarget = null; // Сбрасываем текущую цель\r\n        }\r\n\r\n        // Уменьшаем время перезарядки атаки, если оно активно\r\n        if(this.attackCooldown > 0) {\r\n            this.attackCooldown--;\r\n        }\r\n    }\r\n\r\n    // Проверка, находится ли человек рядом (в радиусе обнаружения)\r\n    isHumanNear(human) {\r\n        return this.distanceTo(human) < this.detectionRadius;\r\n    }\r\n\r\n    // Метод преследования цели\r\n    chase(human){\r\n        // Предсказание движения цели (преследование с упреждением)\r\n        const prediction = 10;\r\n        const humanFutureX = human.x + Math.cos(human.direction) * prediction;\r\n        const humanFutureY = human.y + Math.sin(human.direction) * prediction;\r\n\r\n        // Устанавливаем направление движения к предсказанной позиции цели\r\n        this.direction = Math.atan2(humanFutureY - this.y, humanFutureX-this.x);\r\n\r\n        // Двигаемся в направлении цели\r\n        this.x += Math.cos(this.direction) * this.speed;\r\n        this.y += Math.sin(this.direction) * this.speed;\r\n        this.applyBoundaries(); // Проверяем границы игрового поля\r\n    }\r\n\r\n    // Метод атаки цели\r\n    attack(target) {\r\n        // Если атака не на перезарядке и у цели есть здоровье\r\n        if(this.attackCooldown <= 0 && target.health !== undefined) {\r\n            target.health -= this.attackPower; // Наносим урон\r\n            this.attackCooldown = this.attackRate; // Устанавливаем перезарядку\r\n\r\n            // Если цель умерла - сбрасываем текущую цель\r\n            if(target.health <= 0) {\r\n                this.currentTarget = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Метод случайного блуждания\r\n    randomWalk(){\r\n        // Если цикл ходьбы закончился - выбираем новое случайное направление\r\n        if(this.walkCucle <= 0) {\r\n            this.walkangle = Math.random() * Math.PI * 2;\r\n            this.walkCucle = 50 + Math.random() * 50; // Устанавливаем новый цикл\r\n        }\r\n\r\n        this.walkCucle--; // Уменьшаем цикл ходьбы\r\n\r\n        // Плавно меняем направление к walkangle\r\n        const angleDiff = this.walkangle - this.direction;\r\n        this.direction += angleDiff * 0.05;\r\n\r\n        // Двигаемся с небольшой случайной вариацией скорости\r\n        const currentSpeed = this.speed * (0.3 + Math.random() * 0.2);\r\n        this.x += Math.cos(this.direction) * currentSpeed;\r\n        this.y += Math.sin(this.direction) * currentSpeed;\r\n\r\n        // Если достигли границы по X - меняем направление\r\n        if(this.x <= 10 || this.x >= 790) {\r\n            this.walkangle = Math.PI - this.direction;\r\n            this.walkCucle = 30;\r\n        }\r\n        // Если достигли границы по Y - меняем направление\r\n        if (this.y <= 10 || this.y >= 590) {\r\n            this.walkangle = -this.direction;\r\n            this.walkCucle = 30;\r\n        }\r\n\r\n        this.applyBoundaries(); // Проверяем границы\r\n    }\r\n\r\n    // Метод ограничения позиции в пределах игрового поля\r\n    applyBoundaries() {\r\n        this.x = Math.max(10, Math.min(790, this.x));\r\n        this.y = Math.max(10, Math.min(590, this.y));\r\n    }\r\n\r\n    // Метод поиска ближайшего человека из списка\r\n    findClosestHuman(humans) {\r\n        if(humans.length === 0) return null; // Если список пуст - возвращаем null\r\n\r\n        // Используем reduce для поиска человека с минимальным расстоянием\r\n        return humans.reduce((closest, human) => {\r\n            const dist = this.distanceTo(human)\r\n            return dist < closest.dist ? { human, dist } : closest\r\n          }, { human: null, dist: Infinity }).human;\r\n    }\r\n\r\n    // Метод расчета расстояния до сущности\r\n    distanceTo(entity) {\r\n        return Math.hypot(this.x - entity.x, this.y - entity.y);\r\n    }\r\n}","// Класс, представляющий человека в симуляции\r\nexport class Human {\r\n    // Конструктор класса Human\r\n    constructor(x, y, speed = 1.0, infectionTime = 3000, detectionRadius = 100) {\r\n        this.x = x;             // Координата X положения человека\r\n        this.y = y;             // Координата Y положения человека\r\n        this.radius = 5;        // Радиус человека (для отрисовки)\r\n        this.speed = speed;     // Скорость перемещения\r\n        this.infected = false;  // Флаг заражения (зомби-вирусом)\r\n        this.color = 'hsl(25, 60%, 70%)';   // Цвет для отрисовки (телесный)\r\n        this.detectionRadius = detectionRadius;// Радиус обнаружения зомби\r\n        this.panicMode = false; // Режим паники (убегания от зомби)\r\n        this.infectionProgress = 0; // Прогресс заражения (0-100%)\r\n        this.infectionTime = infectionTime; // Время полного заражения (в мс)\r\n        this.direction = Math.random() * Math.PI * 2;   // Направление движения (случайное)\r\n        this.panicTimer = 0;    // Таймер панического поведения\r\n        this.lastThreatPos = null;  // Последняя известная позиция угрозы\r\n        this.isHealing = false; // Флаг процесса лечения\r\n    }\r\n\r\n    // Метод перемещения человека\r\n    move(zombies, medics) {\r\n        // Если человек в процессе лечения - не двигается\r\n        if(this.isHealing) return;\r\n\r\n        // Если есть прогресс заражения - особое поведение зараженного\r\n        if(this.infectionProgress > 0) {\r\n            this.moveInfected(medics);\r\n            return\r\n        }\r\n        // Поиск ближайшего зомби среди всех зомби\r\n        const closestZombie = this.findClosestZombie(zombies);\r\n\r\n        // Проверка, находится ли зомби достаточно близко\r\n        if(closestZombie && this.isZombieNear(closestZombie)) {\r\n            // Убегание от зомби\r\n            this.runFrom(closestZombie);\r\n            this.panicMode = true; // Включение режима паники\r\n        } else {\r\n            // Если таймер паники еще активен - продолжать движение в панике\r\n            if (this.panicTimer > 0) {\r\n                this.panicTimer--;\r\n                this.x += Math.cos(this.direction) * this.speed;\r\n                this.y += Math.sin(this.direction) * this.speed;\r\n                this.applyBoundaries();\r\n                return;\r\n            }\r\n            // Обычное случайное блуждание\r\n            this.randomWalk();\r\n            this.panicMode = false; // Выключение режима паники\r\n        }\r\n    }\r\n\r\n    // Проверка, находится ли зомби достаточно близко\r\n    isZombieNear(zombie) {\r\n        // Расчет расстояния до зомби\r\n        return this.distanceTo(zombie) < this.detectionRadius;\r\n    }\r\n\r\n    // Метод убегания от зомби\r\n    runFrom(zombie) {\r\n        // Расчет угла направления от зомби\r\n        const angle = Math.atan2(this.y - zombie.y, this.x - zombie.x);\r\n        this.direction = angle + (Math.random() - 0.5) * (Math.PI/3);\r\n        // Избегание стен с большим запасом (20px)\r\n        this.avoidWalls(20);\r\n\r\n        // Движение в выбранном направлении\r\n        this.x += Math.cos(this.direction) * this.speed;\r\n        this.y += Math.sin(this.direction) * this.speed;\r\n\r\n        // Проверка границ игрового поля\r\n        this.applyBoundaries();\r\n\r\n        // Запоминаем позицию угрозы\r\n        this.lastThreatPos = {x: zombie.x, y:zombie.y};\r\n        this.panicTimer = 60;// Устанавливаем таймер паники\r\n    }\r\n\r\n    // Метод случайного блуждания\r\n    randomWalk() {\r\n        // 0.5% шанс изменить направление в случайную сторону\r\n        if(Math.random() < 0.005 || !this.direction) {\r\n            this.direction = Math.random() * Math.PI * 2;\r\n        }\r\n\r\n        // Добавляем небольшие случайные отклонения в направлении\r\n        this.direction += (Math.random() - 0.5) * 0.15;\r\n\r\n        // Движение в выбранном направлении\r\n        this.x += Math.cos(this.direction) * this.speed;\r\n        this.y += Math.sin(this.direction) * this.speed;\r\n\r\n        // Избегание стен с небольшим запасом (5px)\r\n        this.avoidWalls(5);\r\n\r\n        // Проверка границ игрового поля\r\n        this.applyBoundaries();\r\n    }\r\n\r\n    // Метод движения зараженного человека\r\n    moveInfected(medics) {\r\n        // Проверка, что заражение в процессе\r\n        if(this.infectionProgress > 0 && this.infectionProgress < 100) {\r\n            // Поиск доступных медиков (не зараженных)\r\n            const availableMedics = medics.filter(m => \r\n                m.infectionProgress === 0\r\n            );\r\n\r\n            // Поиск ближайшего медика\r\n            const closestMedic = this.findClosestMedic(availableMedics);\r\n\r\n            // Если медик найден и не в панике\r\n            if(closestMedic && !closestMedic.panicMode) {\r\n                // Расчет расстояния до медика\r\n                const distToMedic = this.distanceTo(closestMedic);\r\n\r\n                // Если медик достаточно близко\r\n                if(distToMedic < this.detectionRadius * 2) {\r\n                    // Расчет направления к медику\r\n                    const angle = Math.atan2(closestMedic.y - this.y, closestMedic.x - this.x);\r\n                    this.direction = angle + (Math.random() - 0.5) * 0.1;\r\n\r\n                    // Движение к медику\r\n                    this.x += Math.cos(this.direction) * this.speed;\r\n                    this.y += Math.sin(this.direction) * this.speed;\r\n                    this.applyBoundaries();\r\n                    return;\r\n                }\r\n            }\r\n            // Если медиков нет или они далеко - случайное блуждание\r\n            this.randomWalk();\r\n        }\r\n    }\r\n\r\n    // Метод поиска ближайшего медика\r\n    findClosestMedic(medics) {\r\n        // Если медиков нет - возвращаем null\r\n        if(medics.length === 0) return null;\r\n\r\n        let closest = null;     // Ближайший медик\r\n        let minDist = Infinity; // Минимальное расстояние\r\n\r\n        // Перебираем всех медиков\r\n        for(const medic of medics) {\r\n            // Расчет расстояния до медика\r\n            const dist = this.distanceTo(medic);\r\n\r\n            // Если медик ближе предыдущего ближайшего\r\n            if(dist < minDist) {\r\n                minDist = dist;\r\n                closest = medic;\r\n            }\r\n        }\r\n        return closest;\r\n    }\r\n\r\n    // Метод ограничения движения границами поля\r\n    applyBoundaries() {\r\n        this.x = Math.max(10, Math.min(790, this.x));\r\n        this.y = Math.max(10, Math.min(590, this.y));\r\n    }\r\n\r\n    // Метод избегания стен\r\n    avoidWalls(margin) {\r\n        // Расчет следующей позиции с учетом запаса\r\n        const nextX = this.x + Math.cos(this.direction) * margin;\r\n        const nextY = this.y + Math.sin(this.direction) * margin;\r\n\r\n        // Проверка левой/правой границы\r\n        if(nextX < 10 || nextX > 790) {\r\n            if(!this.panicMode) {\r\n                // В обычном режиме - отражение от стен\r\n                this.direction = Math.atan2(Math.sin(this.direction), -Math.cos(this.direction));\r\n            } else {\r\n                // В режиме паники - резкий поворот\r\n                this.direction = nextY < this.y ? -Math.PI/2 : Math.PI/2;\r\n            }\r\n        }\r\n        // Проверка верхней/нижней границы\r\n        else if (nextY < 10 || nextY > 590) {\r\n            if(!this.panicMode) {\r\n                // В обычном режиме - отражение от стен\r\n                this.direction = Math.atan2(-Math.sin(this.direction), Math.cos(this.direction));\r\n            }\r\n            else {\r\n                // В режиме паники - резкий поворот\r\n                this.direction = nextX < this.x ? Math.PI : 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Метод поиска ближайшего зомби\r\n    findClosestZombie(zombies) {\r\n        // Если зомби нет - возвращаем null\r\n        if(zombies.length === 0) return null;\r\n\r\n        let closest = null;     // Ближайший зомби\r\n        let minDist = Infinity; // Минимальное расстояние\r\n\r\n        // Перебираем всех зомби\r\n        for(const zombie of zombies) {\r\n             // Расчет расстояния до зомби\r\n            const dist = this.distanceTo(zombie);\r\n\r\n            // Если зомби ближе предыдущего ближайшего\r\n            if(dist < minDist) {\r\n                minDist = dist;\r\n                closest = zombie;\r\n            }\r\n        }\r\n        return closest;\r\n    }\r\n\r\n    // Метод обновления состояния заражения\r\n    updateInfection(deltaTime){\r\n        // Если заражение началось\r\n        if(this.infectionProgress > 0){\r\n            // Увеличение прогресса заражения\r\n            this.infectionProgress += deltaTime / this.infectionTime * 100;\r\n\r\n            // Изменение цвета в зависимости от прогресса заражения\r\n            this.color = `hsl(${25 - (25 * this.infectionProgress/100)}, ${60 + (40 * this.infectionProgress/100)}%, ${70 - (40 * this.infectionProgress/100)}%)`;\r\n        }\r\n    }\r\n\r\n    // Метод проверки близости к точке\r\n    isTooClose(x, y, minDist) {\r\n        return Math.hypot(this.x - x, this.y - y) < minDist;\r\n    }\r\n\r\n    // Метод расчета расстояния до объекта\r\n    distanceTo(entity) {\r\n        return Math.hypot(this.x - entity.x, this.y - entity.y);\r\n    }\r\n}","//Класс медика\r\nexport class Medic {\r\n    //Конструктор класса\r\n    constructor(x, y, speed = 1.2, healingPower = 2, detectionRadius = 150, infectionTime = 6000) {\r\n        this.x = x || Math.random() * 700 + 50;         //Позиция X\r\n        this.y = y || Math.random() * 500 + 50;         //Позиция Y\r\n        this.speed = speed;                             //Скорость передвижения\r\n        this.healingPower = healingPower;               //Сила лечения(на сколько уменьшается заражение)\r\n        this.detectionRadius = detectionRadius;         //Радиус обнаружения зараженных/зомби\r\n        this.infectionTime = infectionTime;             //Время полного заражения в мс\r\n        this.radius = 6;                                //Радиус для отрисовки\r\n        this.color = 'hsl(165, 80%, 60%)';            //Цвет - голубовато-зелёный\r\n        this.currentTarget = null;                      //Текущая цель для лечения\r\n        this.direction = Math.random() * Math.PI * 2;   //Направление движения\r\n        this.infectionProgress = 0;                     //Прогресс заражения\r\n        this.isHealing = false;                         //Флаг,лечит ли сейчас медик\r\n        this.panicMode = false;                         //Флаг режима паники\r\n        this.panicTimer = 0;                            //Таймер режима паники\r\n        this.lastThreatPos = null;                      //Последняя известная позиция угрозы\r\n    }\r\n\r\n    // Основной метод движения медика\r\n    move(humans, zombies, medics) {\r\n        // Если медик уже заражен - используем специальное поведение\r\n        if(this.infectionProgress > 0) {\r\n            this.moveInfected(medics);\r\n            return;\r\n        }\r\n\r\n        // Находим ближайшего зомби\r\n        const nearestZombie = this.findClosestZombie(zombies);\r\n\r\n        // Если зомби рядом - убегаем от него\r\n        if (nearestZombie && this.isZombieNear(nearestZombie)) {\r\n            this.runFrom(nearestZombie);\r\n            this.panicMode = true;\r\n            this.panicTimer = 60;\r\n\r\n            // Сбрасываем текущую цель лечения\r\n            if (this.currentTarget) {\r\n                this.currentTarget.isHealing = false;\r\n                this.currentTarget = null;\r\n                this.isHealing = false;\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Если таймер паники еще активен - продолжаем движение в панике\r\n        if(this.panicTimer > 0) {\r\n            this.panicTimer--;\r\n            this.x += Math.cos(this.direction) * this.speed;\r\n            this.y += Math.sin(this.direction) * this.speed;\r\n            this.applyBoundaries();\r\n            return;\r\n        }\r\n\r\n        // Выходим из режима паники\r\n        this.panicMode = false;\r\n\r\n        // Фильтруем зараженных людей и медиков\r\n        const infectedHumans = humans.filter(h => h.infectionProgress > 0 && h.infectionProgress < 100);\r\n        const infectedMedics = medics.filter(m => m.infectionProgress > 0 && m.infectionProgress < 100);\r\n        const infected = this.findClosestInfected([...infectedHumans, ...infectedMedics]);\r\n\r\n        // Если есть зараженные для лечения\r\n        if(infected) {\r\n            // Если зараженный в радиусе обнаружения - идем к нему\r\n            if(this.distanceTo(infected) < this.detectionRadius) {\r\n                this.currentTarget = infected;\r\n                this.goTo(this.currentTarget);\r\n            } else {\r\n                // Иначе - случайное блуждание\r\n                this.randomWalk();\r\n            }\r\n\r\n            // Если достигли зараженного - начинаем лечение\r\n            if(this.distanceTo(infected) < this.radius + infected.radius + 3) {\r\n                this.isHealing = true;\r\n                this.heal(infected);\r\n            } else {\r\n                // Если не достигли - прекращаем лечение\r\n                this.isHealing = false;\r\n                if(this.currentTarget) this.currentTarget.isHealing = false;\r\n            }\r\n        } else {\r\n            // Если нет целей для лечения - случайное блуждание\r\n            this.isHealing = false;\r\n            if (this.currentTarget) {\r\n                this.currentTarget.isHealing = false;\r\n                this.currentTarget = null;\r\n            }\r\n            this.randomWalk();\r\n        }\r\n    }\r\n\r\n    // Проверка, находится ли зомби рядом\r\n    isZombieNear(zombie) {\r\n        return Math.hypot(this.x - zombie.x, this.y - zombie.y) < this.detectionRadius;\r\n    }\r\n\r\n    // Метод лечения зараженного\r\n    heal(human) {\r\n        // Уменьшаем прогресс заражения (но не меньше 0)\r\n        human.infectionProgress = Math.max(0, human.infectionProgress - this.healingPower);\r\n        human.isHealing = true;\r\n\r\n        // Если полностью вылечили - сбрасываем флаги\r\n        if(human.infectionProgress === 0) {\r\n            human.infected = false;\r\n            human.isHealing = false;\r\n            if(this.currentTarget) {\r\n                this.currentTarget = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Метод движения к цели\r\n    goTo(infected) {\r\n        // Плавное изменение направления\r\n        const targetDir = Math.atan2(infected.y - this.y, infected.x - this.x);\r\n        \r\n        // Если направление не определено - устанавливаем сразу\r\n        if (typeof this.direction === 'undefined') {\r\n            this.direction = targetDir;\r\n        } else {\r\n            // Мягкая корректировка курса (20% от разницы)\r\n            const angleDiff = ((targetDir - this.direction + Math.PI) % (Math.PI * 2)) - Math.PI;\r\n            this.direction += angleDiff * 0.3;\r\n        }\r\n\r\n        // Случайные микрокоррекции для естественности\r\n        this.direction += (Math.random() - 0.5) * 0.02;\r\n\r\n        // Динамическая скорость (медленнее при приближении)\r\n        const dist = this.distanceTo(infected);\r\n        const speed = dist < 50 ? this.speed * (dist / 50) * 0.8 : this.speed;\r\n\r\n        // Движение в выбранном направлении\r\n        this.x += Math.cos(this.direction) * speed;\r\n        this.y += Math.sin(this.direction) * speed;\r\n\r\n        // Избегание стен\r\n        this.avoidWalls(20);\r\n\r\n        // Проверка границ игрового поля\r\n        this.applyBoundaries();\r\n    }\r\n\r\n    // Метод убегания от зомби\r\n    runFrom(zombie) {\r\n        // Расчет угла направления от зомби\r\n        const angle = Math.atan2(this.y - zombie.y, this.x - zombie.x);\r\n        this.direction = angle + (Math.random() - 0.5) * (Math.PI/3);\r\n\r\n        // Избегание стен с большим запасом (20px)\r\n        this.avoidWalls(20);\r\n\r\n        // Движение в выбранном направлении\r\n        this.x += Math.cos(this.direction) * this.speed;\r\n        this.y += Math.sin(this.direction) * this.speed;\r\n\r\n        // Проверка границ игрового поля\r\n        this.applyBoundaries();\r\n\r\n        // Запоминаем позицию угрозы\r\n        this.lastThreatPos = {x: zombie.x, y:zombie.y};\r\n        this.panicTimer = 60;// Устанавливаем таймер паники\r\n    }\r\n\r\n    // Метод случайного блуждания\r\n    randomWalk() {\r\n        // 0.5% шанс изменить направление в случайную сторону\r\n        if(Math.random() < 0.005 || !this.direction) {\r\n            this.direction = Math.random() * Math.PI * 2;\r\n        }\r\n\r\n        // Добавляем небольшие случайные отклонения в направлении\r\n        this.direction += (Math.random() - 0.5) * 0.15;\r\n\r\n        // Движение в выбранном направлении\r\n        this.x += Math.cos(this.direction) * this.speed;\r\n        this.y += Math.sin(this.direction) * this.speed;\r\n\r\n        // Избегание стен с небольшим запасом (5px)\r\n        this.avoidWalls(5);\r\n\r\n        // Проверка границ игрового поля\r\n        this.applyBoundaries();\r\n    }\r\n\r\n    // Метод ограничения позиции в пределах игрового поля\r\n    applyBoundaries() {\r\n        this.x = Math.max(10, Math.min(790, this.x));\r\n        this.y = Math.max(10, Math.min(590, this.y));\r\n    }\r\n\r\n    // Метод избегания стен\r\n    avoidWalls(margin) {\r\n        // Расчет следующей позиции с учетом запаса\r\n        const nextX = this.x + Math.cos(this.direction) * margin;\r\n        const nextY = this.y + Math.sin(this.direction) * margin;\r\n\r\n        // Проверка левой/правой границы\r\n        if(nextX < 10 || nextX > 790) {\r\n            if(!this.panicMode) {\r\n                // В обычном режиме - отражение от стен\r\n                this.direction = Math.atan2(Math.sin(this.direction), -Math.cos(this.direction));\r\n            } else {\r\n                // В режиме паники - резкий поворот\r\n                this.direction = nextY < this.y ? -Math.PI/2 : Math.PI/2;\r\n            }\r\n        }\r\n        // Проверка верхней/нижней границы\r\n        else if (nextY < 10 || nextY > 590) {\r\n            if(!this.panicMode) {\r\n                // В обычном режиме - отражение от стен\r\n                this.direction = Math.atan2(-Math.sin(this.direction), Math.cos(this.direction));\r\n            }\r\n            else {\r\n                // В режиме паники - резкий поворот\r\n                this.direction = nextX < this.x ? Math.PI : 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Метод поиска ближайшей сущности\r\n    findClosestEntity(entitys) {\r\n        if(entitys.length === 0) return null;\r\n\r\n        let closest = null;     \r\n        let minDist = Infinity; // Минимальное расстояние\r\n\r\n        for(const entity of entitys) {\r\n            // Расчет расстояния до медика\r\n            const dist = this.distanceTo(entity);\r\n\r\n            if(dist < minDist) {\r\n                minDist = dist;\r\n                closest = entity;\r\n            }\r\n        }\r\n        return closest;\r\n    }\r\n\r\n    // Метод поиска ближайшего зараженного\r\n    findClosestInfected(humans) {\r\n         return this.findClosestEntity(humans);\r\n    }\r\n\r\n    // Метод поиска ближайшего зомби\r\n    findClosestZombie(zombies) {\r\n        return this.findClosestEntity(zombies);\r\n    }\r\n\r\n    // Метод расчета расстояния до сущности\r\n    distanceTo(entity) {\r\n        return Math.hypot(this.x - entity.x, this.y - entity.y);\r\n    }\r\n\r\n    // Метод обновления состояния заражения\r\n    updateInfection(deltaTime){\r\n        // Увеличиваем прогресс заражения\r\n        if(this.infectionProgress > 0){\r\n            this.infectionProgress += deltaTime / this.infectionTime * 100;\r\n\r\n            // Изменяем цвет в зависимости от прогресса заражения\r\n            this.color = `hsl(${165 - (165 * this.infectionProgress/100)}, ${80 + (20 * this.infectionProgress/100)}%, ${60 - (30 * this.infectionProgress/100)}%)`;\r\n        }\r\n    }\r\n\r\n    // Метод поиска ближайшего медика\r\n    findClosestMedic(medics) {\r\n        return this.findClosestEntity(medics);\r\n    }\r\n\r\n    // Метод движения зараженного медика\r\n    moveInfected(medics) {\r\n        // Проверка, что заражение в процессе\r\n        if(this.infectionProgress > 0 && this.infectionProgress < 100) {\r\n            // Поиск доступных медиков (не зараженных)\r\n            const availableMedics = medics.filter(m => \r\n                m.infectionProgress === 0\r\n            );\r\n\r\n            // Поиск ближайшего медика\r\n            const closestMedic = this.findClosestMedic(availableMedics);\r\n\r\n            // Если медик найден и не в панике\r\n            if(closestMedic && !closestMedic.panicMode) {\r\n                // Расчет расстояния до медика\r\n                const distToMedic = this.distanceTo(closestMedic);\r\n\r\n                // Если медик достаточно близко\r\n                if(distToMedic < this.detectionRadius * 2) {\r\n                    // Расчет направления к медику\r\n                    const angle = Math.atan2(closestMedic.y - this.y, closestMedic.x - this.x);\r\n                    this.direction = angle + (Math.random() - 0.5) * 0.1;\r\n\r\n                    // Движение к медику\r\n                    this.x += Math.cos(this.direction) * this.speed;\r\n                    this.y += Math.sin(this.direction) * this.speed;\r\n                    this.applyBoundaries();\r\n                    return;\r\n                }\r\n            }\r\n            // Если медиков нет или они далеко - случайное блуждание\r\n            this.randomWalk();\r\n        }\r\n    }\r\n\r\n}","// Класс, представляющий охранника/защитника в симуляции\r\nexport class Guardian {\r\n    //Конструктор класса\r\n    constructor(x, y, speed = 0.6, detectionRadius = 100, attackRadius = 50, attackPower = 1, attackRate = 60, maxHealth = 3) {\r\n        this.x = x || Math.random() * 700 + 50;     // Координата X положения охранника\r\n        this.y = y || Math.random() * 500 + 50;     // Координата Y положения охранника\r\n        this.detectionRadius = detectionRadius;     // Радиус обнаружения зомби\r\n        this.speed = speed;                         // Скорость перемещения\r\n        this.radius = 7;                            // Размер охранника (для отрисовки)\r\n        this.color = 'hsl(225, 85%, 40%)';        // Цвет охранника (синий)\r\n        this.direction = Math.random() * Math.PI * 2;   // Начальное направление движения\r\n        this.currentTarget = null;                  // Текущая цель для атаки\r\n\r\n        // Параметры здоровья и атаки\r\n        this.attackPower = attackPower;             // Сила атаки\r\n        this.attackCooldown = 0;                    // Время до следующей атаки\r\n        this.attackRate = attackRate;               // Частота атак (в кадрах)\r\n        this.attackRadius = attackRadius;           // Радиус атаки\r\n        this.maxHealth = maxHealth;                 // Максимальное здоровье\r\n        this.health = maxHealth;                    // Текущее здоровье\r\n    }\r\n\r\n    // Основной метод движения охранника\r\n    move(zombies) {\r\n        // Если нет текущей цели или цель мертва - ищем новую\r\n        if(!this.currentTarget || this.currentTarget.health <= 0) {\r\n            this.currentTarget = this.findClosestZombie(zombies.filter(z => z.health > 0));\r\n        }\r\n\r\n        // Если есть цель\r\n        if(this.currentTarget) {\r\n            const dist = this.distanceTo(this.currentTarget);\r\n\r\n            // Если цель в радиусе атаки - атакуем\r\n            if(dist < this.attackRadius) {\r\n                this.attack(this.currentTarget);\r\n            }\r\n            // Если цель в радиусе обнаружения - преследуем\r\n            else if(dist < this.detectionRadius) {\r\n                this.chase(this.currentTarget);\r\n            }\r\n            // Если цель слишком далеко - теряем её и бродим случайно\r\n            else {\r\n                this.currentTarget = null;\r\n                this.randomWalk();\r\n            }\r\n        } else {\r\n            // Если цели нет - бродим случайно\r\n            this.randomWalk();\r\n        }\r\n\r\n        // Уменьшаем время перезарядки атаки\r\n        if(this.attackCooldown > 0) {\r\n            this.attackCooldown--;\r\n        }\r\n\r\n        // Проверяем границы игрового поля\r\n        this.applyBoundaries();\r\n    }\r\n\r\n    // Метод атаки\r\n    attack(zombie) {\r\n        // Если атака не на перезарядке\r\n        if(this.attackCooldown <= 0) {\r\n            zombie.health -= this.attackPower;      // Наносим урон\r\n            this.attackCooldown = this.attackRate;  // Устанавливаем перезарядку\r\n\r\n            // Если зомби умер - сбрасываем цель\r\n            if(zombie.health <= 0) {\r\n                this.currentTarget = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Метод преследования цели\r\n    chase(zombie) {\r\n        // Расчет направления к цели\r\n        this.direction = Math.atan2(zombie.y - this.y, zombie.x - this.x);\r\n\r\n        // Движение в направлении цели\r\n        this.x += Math.cos(this.direction) * this.speed;\r\n        this.y += Math.sin(this.direction) * this.speed;\r\n\r\n        // Проверка границ\r\n        this.applyBoundaries();\r\n    }\r\n\r\n    // Метод случайного блуждания\r\n    randomWalk() {\r\n        // С шансом 0.5% или если направление не задано - выбираем новое случайное направление\r\n        if(Math.random() < 0.005 || !this.direction) {\r\n            this.direction = Math.random() * Math.PI * 2;\r\n        }\r\n\r\n        // Добавляем небольшие случайные отклонения в направлении\r\n        this.direction += (Math.random() - 0.5) * 0.15;\r\n\r\n        // Движение в текущем направлении\r\n        this.x += Math.cos(this.direction) * this.speed;\r\n        this.y += Math.sin(this.direction) * this.speed;\r\n\r\n        // Избегаем столкновений со стенами\r\n        this.avoidWalls(5);\r\n\r\n        // Проверка границ\r\n        this.applyBoundaries();\r\n    }\r\n\r\n    // Метод поиска ближайшего зомби\r\n    findClosestZombie(zombies) {\r\n        // Если зомби нет - возвращаем null\r\n        if(zombies.length === 0) return null;\r\n\r\n        let closest = null;     // Ближайший зомби\r\n        let minDist = Infinity; // Минимальное расстояние\r\n\r\n        // Перебираем всех зомби\r\n        for(const zombie of zombies) {\r\n             // Расчет расстояния до зомби\r\n            const dist = this.distanceTo(zombie);\r\n\r\n            // Если зомби ближе предыдущего ближайшего\r\n            if(dist < minDist) {\r\n                minDist = dist;\r\n                closest = zombie;\r\n            }\r\n        }\r\n        return closest;\r\n    }\r\n\r\n    // Метод расчета расстояния до объекта\r\n    distanceTo(entity) {\r\n        return Math.hypot(this.x - entity.x, this.y - entity.y);\r\n    }\r\n\r\n    // Метод ограничения движения границами поля\r\n    applyBoundaries() {\r\n        this.x = Math.max(10, Math.min(790, this.x));\r\n        this.y = Math.max(10, Math.min(590, this.y));\r\n    }\r\n\r\n    // Метод избегания стен\r\n    avoidWalls(margin) {\r\n        // Расчет следующей позиции с учетом запаса\r\n        const nextX = this.x + Math.cos(this.direction) * margin;\r\n        const nextY = this.y + Math.sin(this.direction) * margin;\r\n\r\n        // Проверка левой/правой границы\r\n        if(nextX < 10 || nextX > 790) {\r\n            this.direction = Math.atan2(Math.sin(this.direction), -Math.cos(this.direction));\r\n        }\r\n        // Проверка верхней/нижней границы\r\n        else if (nextY < 10 || nextY > 590) {\r\n            this.direction = Math.atan2(-Math.sin(this.direction), Math.cos(this.direction));\r\n        }\r\n    }\r\n}","import { render } from \"./App.vue?vue&type=template&id=5e9e59e5\"\nimport script from \"./App.vue?vue&type=script&lang=js\"\nexport * from \"./App.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","// Импорт функции создания Vue-приложения из библиотеки Vue\nimport { createApp } from 'vue'\n\n// Импорт корневого компонента приложения\nimport App from './App.vue'\n\n// Импорт глобальных стилей для всего приложения\nimport './styles.css'\n\n// Создание экземпляра приложения и его монтирование\ncreateApp(App).mount('#app')\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t524: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkzombie_app\"] = self[\"webpackChunkzombie_app\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [504], function() { return __webpack_require__(6829); })\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["class","ref","width","height","_createElementBlock","_hoisted_1","_createElementVNode","_hoisted_2","_hoisted_3","_hoisted_4","$data","simulationEnd","onClick","_cache","args","$options","handleControlClick","_normalizeClass","isRunning","isPaused","mainButtonText","resetSim","_hoisted_5","zombies","length","_hoisted_6","_hoisted_7","_hoisted_8","_hoisted_9","_toDisplayString","_hoisted_10","stats","healthy","medics","guardians","humans","_hoisted_11","_hoisted_12","_hoisted_13","time","simulationStarted","_hoisted_14","_hoisted_15","_hoisted_16","settings","population","$event","showHumanSettings","title","type","min","max","step","number","_hoisted_17","_hoisted_18","humanSpeed","toFixed","_hoisted_19","infectionTime","_hoisted_20","detectionRadiusHumans","_hoisted_21","_hoisted_22","zombiePopulation","showZombieSettings","_hoisted_23","_hoisted_24","zombieSpeed","_hoisted_25","infectionRadius","_hoisted_26","detectionRadiusZombie","_hoisted_27","maxHealthZombie","_hoisted_28","attackPowerZombie","_hoisted_29","attackRateZombie","_hoisted_30","_hoisted_31","medicsPopulation","showMedicSettings","_hoisted_32","_hoisted_33","medicSpeed","_hoisted_34","healingPower","_hoisted_35","detectionRadiusMedic","_hoisted_36","infectionTimeMedic","_hoisted_37","_hoisted_38","guardiansPopulation","showGuardianSettings","_hoisted_39","_hoisted_40","guardianSpeed","_hoisted_41","detectionRadiusGuardian","_hoisted_42","attackRadiusGuardian","_hoisted_43","attackPowerGuardian","_hoisted_44","attackRateGuardian","_hoisted_45","maxHealthGuardian","_hoisted_46","saveSettings","cancelSettings","resetSettings","_hoisted_47","_hoisted_48","_hoisted_49","_hoisted_50","_hoisted_51","infected","_hoisted_52","_hoisted_53","_hoisted_54","_hoisted_55","_hoisted_56","_hoisted_57","_hoisted_58","_hoisted_59","Zombie","constructor","x","y","speed","detectionRadius","maxHealth","attackPower","attackRate","this","Math","random","radius","direction","PI","color","currentTarget","targetLockTimer","walkCucle","walkangle","health","attackCooldown","move","infectionProgress","dist","distanceTo","isTargetValid","undefined","attack","chase","allHumans","filter","h","m","g","closestHuman","findClosestHuman","isHumanNear","randomWalk","human","prediction","humanFutureX","cos","humanFutureY","sin","atan2","applyBoundaries","target","angleDiff","currentSpeed","reduce","closest","Infinity","entity","hypot","Human","panicMode","panicTimer","lastThreatPos","isHealing","moveInfected","closestZombie","findClosestZombie","isZombieNear","runFrom","zombie","angle","avoidWalls","availableMedics","closestMedic","findClosestMedic","distToMedic","minDist","medic","margin","nextX","nextY","updateInfection","deltaTime","isTooClose","Medic","nearestZombie","infectedHumans","infectedMedics","findClosestInfected","goTo","heal","targetDir","findClosestEntity","entitys","Guardian","attackRadius","z","data","defaultSettings","ctx","animationId","startTime","elapsedTime","pauseTime","lastPauseTime","lastTime","showSettings","tempSettings","JSON","parse","stringify","mounted","initWorld","computed","methods","stopSim","startSim","$refs","canvas","getContext","i","push","guardian","spawnZombie","performance","now","drawWorld","attempts","maxAttempts","tooClose","some","clearRect","forEach","fillStyle","beginPath","arc","fill","strokeStyle","lineWidth","stroke","pulse","Date","save","healthWidth","healthHeight","healthX","healthY","fillRect","hpPercent","restore","updateStats","$nextTick","$forceUpdate","requestAnimationFrame","update","cancelAnimationFrame","currentTime","floor","toString","padStart","showEndMessage","message","alert","beforeDestroy","__exports__","render","createApp","App","mount","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","deferred","O","result","chunkIds","fn","priority","notFulfilled","fulfilled","j","Object","keys","every","key","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","id","chunkLoadingGlobal","self","bind","__webpack_exports__"],"sourceRoot":""}